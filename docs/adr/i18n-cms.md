# ADR: Стратегия локализации и контентной платформы

**Дата:** 2025-02-14  
**Статус:** утверждено  
**Ответственные:** фронтенд и продуктовая команды Supra Lottery

## Контекст
- Интерфейс Supra Lottery изначально содержал монолитный словарь `messages.ts` и кастомный хук `useI18n`, что затрудняло подключение новых языков, передачу контента в CMS и контроль консистентности переводов.
- В план трансформации входит масштабирование на несколько рынков, help-center и динамический контент (чек-листы, уведомления, база знаний), поэтому необходима стандартная экосистема i18n и возможность выгружать словари для локализационных команд.
- Команды дизайна и поддержки уже подготовили требования к мультиязычности, поэтому важно закрепить единый подход, чтобы не возвращаться к архитектурным решениям после интеграции новых страниц и сервисов.

## Решение
1. **Базовый движок — i18next + react-i18next.**
   - Все переводы хранятся в словарях `src/i18n/messages.ts` (структурированные разделы `layout`, `dashboard`, `tickets` и т.д.).
   - Инициализация вынесена в `src/i18n/initI18n.ts`, используется единый namespace `translation`, поддерживаются локали `ru` и `en`, fallback — `en`.
   - Хук `useI18n` построен поверх `useTranslation`, синхронизирует Zustand-хранилище с i18next и сохраняет API `t(key, params)` для компонентов.
2. **Экспорт словарей для контент-команды.**
   - Скрипт `pnpm run i18n:extract` (реализован на TypeScript) генерирует JSON-файлы `public/locales/<locale>/translation.json`, сортируя ключи и сохраняя читаемый формат.
   - Эти файлы можно передавать переводчикам или загружать в внешний CMS/локализационную платформу; в дальнейшем планируется двусторонняя синхронизация.
3. **Типобезопасность и проверка консистентности.**
   - Типы `Messages` и `CustomTypeOptions` для `react-i18next` позволяют получать подсказки по ключам и структуре словаря в TypeScript.
   - Добавлен `tsconfig.node.json` с областью `scripts/**/*.ts`, чтобы статическая проверка распространялась на утилиты локализации.
4. **Поддержка будущего CMS.**
   - Сохранена возможность подключить headless CMS или Supra AutoFi-хранилище: JSON-файлы могут служить промежуточным форматом для импорта/экспорта.
   - В документации зафиксирован процесс обновления переводов, что упростит переход на внешнюю платформу без изменений кода.

## Альтернативы
- **Сохранить кастомный переводчик.** Отклонено из-за отсутствия экосистемы, поддержки pluralization и tooling.
- **Использовать сторонний SaaS без локального словаря.** Отложено до появления партнёра; текущий подход не мешает дальнейшей интеграции.

## Последствия
- Увеличилось количество зависимостей (`i18next`, `react-i18next`, `tsx`, `ts-node`), но мы получили стандартный API и скрипты для контроля качества переводов.
- Все тесты и окружения должны инициализировать i18n (добавлено в `vitest.setup.ts` и `main.tsx`).
- При добавлении новых ключей нужно запускать `pnpm run i18n:extract`, чтобы синхронизировать JSON-файлы для контентной команды.

## Следующие шаги
- Определить требования к help-center и интеграции с CMS (Zendesk/Notion/локальная база) и подготовить адаптер, использующий тот же формат JSON.
- Добавить lint-проверку, сравнивающую структуры словарей (`en` vs `ru`) в CI, и расширить скрипт `extract-translations` автопроверкой отсутствующих ключей.
- Подготовить гайд для контент-редакторов в `docs/runbooks/localization.md` (следующий таск).
