# План декомпозиции контракта SupraLottery

## Цель

Перестроить монолитный пакета `lottery` на набор независимых Move‑пакетов, чтобы:

1. Уложиться в лимиты размера публикации (≤ 60 KB).
2. Упростить дальнейшее развитие (новые модули/фичи подключаются независимо).
3. Сохранить возможность быстро восстановиться на монолитной версии (`backup/lottery_monolith`).

## Исходная точка

- Бэкап текущего состояния: ветка `backup/lottery_monolith`.
- Основная работа ведётся в ветке `main` (или рабочей ветке, указанной командой).
- Набор пакетов до изменений:
  - `SupraVrf`, `vrf_hub`, `lottery_factory`, `lottery`.
- Ограничение: публикация `lottery` ~83 KB даже без артефактов → сеть отклоняет транзакцию.

## Общая архитектура после разбиения

| Пакет              | Назначение                                                               | Пример содержимого                                     |
|--------------------|--------------------------------------------------------------------------|--------------------------------------------------------|
| `lottery_core`     | Минимальный функционал: покупка билетов, розыгрыш, казначейство          | `Lottery.move`, `LotteryRounds.move`, `Treasury*.move` |
| `lottery_rewards`  | Дополнительные механики для игроков                                      | `Vip.move`, `Referrals.move`, `Autopurchase.move`, `NftRewards.move` |
| `lottery_support`  | Админские и вспомогательные функции                                      | `History.move`, `Metadata.move`, `Migration.move`      |
| `lottery_tests` (опционально) | Интеграционные сценарии и вспомогательные тестовые утилиты | Тесты, которые тянут весь стек                         |

Каждый пакет получает свой `Move.toml`, тесты, команды публикации в runbook.

## Шаги по реализации

### 1. Анализ зависимостей

- Для каждого модуля зафиксировать:
  - `use` зависимости и friend‑отношения.
  - Какие ресурсы/функции предоставляются другим модулям.
- Результат оформить в таблицу (можно добавить в этот документ или `docs/architecture/modules.md`).

### 2. Определение границ пакетов

- **Ядро (`lottery_core`)** — включает модули, без которых нельзя провести базовый розыгрыш.
- **Расширения (`lottery_rewards`)** — фичи для игроков, не требуемые на старте.
- **Поддержка (`lottery_support`)** — история, метаданные, миграция, которые можно публиковать позже.
- Проверить, что внутри каждого пакета:
  - `friend` используется только между модулями пакета.
  - Не остаётся циклических зависимостей.

### 3. Замена `friend` на capability (где необходимо)

- Выявить места, где ядру нужно контролировать доступ (например, `Treasury` ↔ `Vip`, `Referrals`, `Autopurchase`).
- Ввести capability‑структуры в ядре:
  ```move
  struct CoreCapability has key { }
  ```
- При инициализации ядро создаёт и хранит capability в приватном ресурсе.
- Расширения получают capability через публичный guarded API.
- Обновить вызовы: вместо `friend` теперь требуются аргументы capability.

### 4. Создание новых пакетов

Для каждого пакета:

1. Создать директорию (`supra/move_workspace/lottery_core` и т. д.).
2. Сформировать `Move.toml`:
   - `name`, `version`.
   - `addresses` (скопировать из текущего `lottery/Move.toml`).
   - `dependencies` (указать `MoveStdlib`, `SupraFramework`, и `local = "../lottery_core"` для пакетов над ядром).
3. Переместить соответствующие `.move` файлы и тесты.
4. Обновить `use` пути (например, `use lottery::treasury_v1` → `use lottery_core::treasury_v1`).
5. Запустить `supra move tool test --package-dir <dir>` для каждого пакета; убедиться, что сборка проходит.

### 5. Обновление runbook и документации

- В `docs/testnet_runbook.md` добавить команды публикации для каждого нового пакета, например:
  ```powershell
  docker compose run --rm -e SUPRA_PROFILE=my_profile --entrypoint bash supra_cli `
    -lc "/supra/supra move tool publish --package-dir /supra/move_workspace/lottery_core --included-artifacts none --skip-fetch-latest-git-deps --gas-unit-price 100 --max-gas 150000 --expiration-secs 600 --assume-yes"
  ```
- В `README.md`/`docs/architecture/modules.md` описать структуру пакетов и связи между ними.

### 6. Пошаговая публикация

1. Развернуть `lottery_core` (после успешных тестов).
2. Развернуть `lottery_support` и/или `lottery_rewards` (последовательно, с обновлением runbook).
3. Обновить сценарии инициализации (whitelisting, migrate) для новых пакетов, если требуется.

### 7. Проверка и чеклист

- Прогнать интеграционные тесты (`supra/scripts/move_tests.py`, smoke‑скрипты).
- Убедиться, что runbook покрывает:
  - публикацию пакетов,
  - инициализацию ресурсов,
  - whitelisting и работу VRF.
- Зафиксировать версию и сделать релизную ветку (например, `release/core-split`).

### 8. План восстановления

- Для возврата к монолиту:
  - Переключиться на ветку `backup/lottery_monolith` или cherry-pick нужные файлы.
  - Использовать `SupraLottery/supra/move_workspace/lottery_backup` как источник кодовой базы.
- Поддерживать документ в актуальном состоянии (строки runbook, описания capability).

## Рекомендации по управлению ветками

- Все изменения выполняются в основной ветке (по решению команды), а `backup/lottery_monolith` хранится как страховка.
- Каждую группу изменений (capability, перенос модуля, новый пакет) оформлять отдельным коммитом с понятным сообщением.
- После успешной публикации и проверки пакетов оставить тег (например, `v0.2.0-core-split`) для точной точки возврата.

## Контрольные вопросы перед завершением

1. Все ли friend‑отношения заменены или помещены в один пакет?
2. Проходят ли unit-тесты для каждого пакета?
3. Обновлены ли runbook и README?
4. Восстановление в случае отката: есть ли рабочая ветка/тег?
5. Поддерживаются ли capability‑ресурсы безопасно (не `copy`, не `drop`, не «утекают» пользователям)?

Если на все пункты ответ «да», можно переходить к полноценному деплою новой структуры.
