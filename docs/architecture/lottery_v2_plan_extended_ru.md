# План разработки Minimal v2 для SupraLottery (lottery_multi)

Документ на русском языке.  
Цель — создать чистую, модульную, безопасную архитектуру новой версии лотереи без бессмысленных рефакторингов и с возможностью безопасного масштабирования функционала.

---

# 1. Принципы проекта (обязательно соблюдать)

## 1.1. Правила для Move-контрактов
- Никакой кириллицы в исходниках Move.
- Соблюдаем синтаксис **Move v1**, как в текущей версии Supra.
- Новые контракты размещаем только в новом пакете **`lottery_multi`**.
- Старые пакеты (`lottery_core`, `lottery_support`, `lottery_rewards`) не изменяем — они остаются как стабильная база.
- Все новые функции должны быть модульными, не создавать дубликаты логики.
- Архитектура строится так, чтобы можно было:
  - отключать отдельные фичи,
  - включать новые фичи,
  - не ломать существующую структуру.

## 1.2. Ограничения безопасности
- Размер байткода каждого Move-модуля не должен превышать **60 000 байт** (лимит Supra).
- Запрещено избыточное хранение, только минимальные структуры.
- Все `entry`-функции должны проверять:
  - статус лотереи,
  - временное окно,
  - валидность конфигурации.

## 1.3. Стратегия разработки
- Вначале строим **минимальное ядро**, без лишней логики.
- После его стабилизации — добавляем уровни:
  - партнёрские лотереи,
  - capability-система,
  - расширенные призовые модели,
  - премиум-функции,
  - VRF-автоматизация и т. д.

---

# 2. Структура нового пакета `lottery_multi`

## 2.1. Модули
```
lottery_multi::types
lottery_multi::errors
lottery_multi::registry
lottery_multi::sales
lottery_multi::draw
lottery_multi::payouts
lottery_multi::views
```

## 2.2. Что в каждом модуле

### `types`
- базовые структуры
- состояния лотереи
- конфигурация
- статусы VRF

### `errors`
- единый набор ошибок
- пронумерованные константы

### `registry`
- создание лотерей
- хранение конфигураций
- статусы и переходы
- финализация

### `sales`
- покупка билетов
- билеты по чанкам
- учёт количества билетов

### `draw`
- формирование payload
- запись хэша payload
- обработка VRF-колбэка
- защита от повторов

### `payouts`
- распределение наград
- фиксированная простая модель (для v2)
- однозначные события выплат

### `views`
- все функции чтения
- компактные агрегаты
- адаптация под фронтенд

---

# 3. Минимальный функционал v2

## 3.1. Жизненный цикл
```
Draft → Active → Closing → AwaitingVRF → VrfFulfilled → WinnerComputation → Payout → Finalized/Canceled
```

## 3.2. Операции
- создание лотереи  
- покупка билетов  
- закрытие продаж  
- VRF-запрос  
- VRF-обработка  
- определение победителя (детерминированно)  
- выдача наград  

## 3.3. Базовая безопасность
- проверки статуса
- проверки временного окна
- хэш payload VRF
- защита от повторного fulfill
- детерминированный выбор победителей

---

# 4. Функции, которые добавляются позже (V3, V4…)

- Capability-система ролей
- Партнёрские лотереи
- Отключаемые функции (feature flags)
- Автоматизация VRF
- Полная архивная система
- Price feeds
- Джекпоты и продвинутая экономика
- Премиум-подписки
- Governance

---

# 5. Этапы разработки с прогресс-отметками

Можно ставить галочки по мере выполнения.

### Этап 1 — Создать скелет пакета `lottery_multi`
- [ ] Создать директорию
- [ ] Добавить Move.toml и зависимости
- [ ] Создать модули `types` и `errors`

### Этап 2 — Реализовать `registry`
- [ ] Структуры лотереи
- [ ] Переходы статусов
- [ ] Создание лотереи
- [ ] Финализация

### Этап 3 — Реализовать `sales`
- [ ] Билеты (чанки)
- [ ] Покупка билетов
- [ ] Лимиты

### Этап 4 — Реализовать `draw`
- [ ] Формирование payload
- [ ] Хэш payload
- [ ] Валидация VRF
- [ ] Проверка повторов

### Этап 5 — Реализовать `WinnerComputation`
- [ ] Простой детерминированный алгоритм
- [ ] Учет победителя по индексу

### Этап 6 — Реализовать `payouts`
- [ ] Одна базовая модель выплат
- [ ] События выплат

### Этап 7 — Реализовать `views`
- [ ] list active  
- [ ] get lottery summary  
- [ ] get tickets  

### Этап 8 — Добавить минимальные тесты
- [ ] unit-тесты жизненного цикла
- [ ] тесты VRF-потока

### Этап 9 — Финальные проверки
- [ ] Проверить размер байткода каждого модуля (≤ 60 000 байт)
- [ ] move check
- [ ] gas-профиль

---

# 6. Правила, чтобы не наступать на те же грабли

## 6.1. Архитектурные
- Любая новая фича — отдельный модуль или подмодуль.
- Никаких условий “если партнер, если джекпот” — делаем расширяемые структуры.
- В ядре нет логики премиум-функций и ролей — только базовый поток.

## 6.2. Безопасность
- Никакой логики внутри VRF callback — только запись данных.
- Все тяжёлые операции вынести наружу и выполнять вручную.
- Все структуры должны быть неизменяемы после Closing.

## 6.3. Кодстайл
- Названия модулей, функций, переменных — ENG ONLY.
- Никаких смешанных обязанностей между модулями.
- Любой рефакторинг — только после завершения этапа.

## 6.4. Байткод
- Каждый модуль обязан быть **≤ 60 000 bytes**.
- Нельзя объединять большие структуры в один модуль.
- Если размер растёт — сразу выносим в подмодуль.

---

# 7. Команды PowerShell для удобства работы

## Запуск move check
```
docker compose -f SupraLottery/compose.yaml run --rm supra_cli `
  bash -lc "cd /supra/SupraLottery && supra move check"
```

## Запуск тестов
```
docker compose -f SupraLottery/compose.yaml run --rm supra_cli `
  bash -lc "cd /supra/SupraLottery && supra move test"
```

## Запуск форматирования
```
docker compose -f SupraLottery/compose.yaml run --rm supra_cli `
  bash -lc "cd /supra/SupraLottery && supra move fmt"
```

---

# 8. Финальное резюме

Этот документ — минимальный, но полноценный план, который:

- защищает архитектуру от разрастания;
- даёт чёткие этапы разработки;
- исключает повторные рефакторинги;
- учитывает безопасность VRF;
- совместим со старыми контрактами;
- допускает будущие фичи без ломки ядра.

После завершения всех этапов у нас будет прочный каркас для дальнейшего масштабирования.
