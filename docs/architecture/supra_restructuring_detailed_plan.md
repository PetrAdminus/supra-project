# SupraLottery — детальный план реструктуризации (Supra Restructuring Detailed Plan)

## 1. Контекст проекта

**Цель:** превратить текущий набор Move‑пакетов SupraLottery в цельную, расширяемую и безопасную платформу честных и прозрачных Web3‑розыгрышей и лотерей на Supra.

**Исходные условия:**
- Есть рабочий (но фрагментированный) код в нескольких пакетах:
  - `lottery_core`
  - `lottery_multi`
  - `lottery_rewards`
  - `lottery_support`
  - `vrf_hub`
  - `lottery_factory`
- Есть тестовые профили/боты `player1..player5` (конфиги в `configs/playerX.yaml`).
- Сейчас всё деплоится и тестируется на **testnet Supra**, в будущем планируется **mainnet**.
- Фронтенд частично интегрирован, но будет переработан под новую архитектуру.

**Позиционирование:** честный и прозрачный Web3 dApp, с максимально понятной on-chain логикой, событиями и возможностью внешнего аудита.

---

## 2. Жёсткие правила разработки Move

Эти правила обязательны для всех новых и рефакторимых модулей.

1. **Только ASCII в Move‑файлах**
   - Никакой кириллицы в коде и комментариях.
   - Не использовать псевдографику (`─`, `★` и т.п.) — только базовые ASCII‑символы.

2. **Move v1 синтаксис (как в текущем Supra CLI)**
   - Не использовать `let mut`, `loop {}`, и другие конструкции, которые не поддерживаются текущим компилятором Supra.
   - Не использовать зарезервированные слова (`copy`, `move`) как имена переменных.

3. **Ограничение по размеру модулей**
   - Стремиться к тому, чтобы размер байткода **каждого модуля** не превышал ~60 000 байт.
   - Если модуль разрастается — делить его на несколько логических модулей (например, `storage`, `logic`, `events`).

4. **Строгие инварианты и явные ошибки**
   - Для всех критичных проверок использовать константы ошибок `E_*` в одном месте модуля.
   - Не «глушить» ошибки — либо `abort`, либо явное событие с кодом/причиной.

5. **Стиль и читаемость**
   - Единый стиль имён: `snake_case` для функций и переменных, `CamelCase` для структур и ошибок типа `ErrorName`.
   - Отдельные модули под:
     - хранение (storage),
     - бизнес‑логику (logic),
     - события/интерфейсы (events/api),
     - вспомогательные функции (support/utils).

---

## 3. Общая целевая архитектура пакетов

### 3.1. Старая структура и источники правды

Старые пакеты используются как **источник проверенной логики**:
- `lottery_core` — базовые структуры раундов, билетов, логика покупки, выбор победителей, события.
- `lottery_multi` — механика нескольких лотерей, более сложные сценарии.
- `lottery_rewards` — распределение наград, снапшоты.
- `lottery_support` — вспомогательные функции и проверки.
- `vrf_hub` — взаимодействие с Supra VRF, события запросов/результатов.
- `lottery_factory` — создание/инициализация лотерей и связанных ресурсов.

**Важно:** мы не выбрасываем эту логику, а аккуратно переносим в новую структуру.

### 3.2. Новая структура пакетов (целевое состояние)

1. `core_storage`
   - Хранение всех основных on-chain структур:
     - глобальная конфигурация платформы,
     - настройки по лотерее,
     - статусы розыгрышей,
     - история раундов и пр.
   - **Только ресурсы и простые геттеры**, минимум логики.

2. `core_lottery`
   - Бизнес‑логика для всех типов лотерей и розыгрышей:
     - создание/обновление конфигураций,
     - проверки параметров,
     - запуск продажи билетов,
     - обработка покупок,
     - закрытие продаж,
     - подготовка к розыгрышу и применение результатов VRF.
   - Работает через структуры из `core_storage`.

3. `lottery_hub`
   - Внешний «фасад»/реестр лотерей:
     - entry‑функции для фронтенда и пользователей,
     - реестр лотерей по владельцам/организаторам,
     - агрегация статусов и конфигураций.
   - Опирается на `core_storage` и `core_lottery`.

4. `lottery_factory`
   - Низкоуровневое создание сущностей (лотерей/раундов/настроек).
   - Можно частично сохранить из старого `lottery_factory`, адаптировав под `core_storage`.

5. `lottery_rewards`
   - Отдельный пакет для распределения наград и работы со снапшотами.
   - Использует данные из `core_storage` и события из `core_lottery`.

6. `lottery_support`
   - Общие вспомогательные функции:
     - проверки входных параметров,
     - безопасные операции с числами,
     - удобные конверторы/мэппинги.
   - Сюда переносим всё полезное из старого `lottery_support`.

7. `vrf_hub`
   - Пакет взаимодействия с Supra VRF.
   - Стремимся максимально следовать официальным примерам из `Supra-Labs`.
   - Содержит:
     - структуры запросов/ответов VRF,
     - события запроса случайности и получения результата,
     - «хук»/callback для вызова логики из `core_lottery`.

8. `profiles_accounts` (или похожее имя)
   - Структуры профилей пользователей:
     - базовая информация,
     - настройки отображения (например, частичная маскировка адреса),
     - флаг «премиум» и дополнительные права/лимиты.

9. `bots_devtools`
   - Вспомогательные тестовые/разработческие функции.
   - Использует заранее известные тест‑аккаунты (`player1..player5`).
   - **Строго для тестнета и dev‑сценариев**, в mainnet — либо отключено, либо без особых привилегий.

10. `api_governance` (позже)
    - Модули для говернанса и on-chain API для партнёров.
    - Прорабатывается после стабилизации базовой логики лотерей.

---

## 4. Миграция: что брать из старых пакетов

### 4.1. `lottery_core` → `core_storage` + `core_lottery`

**В `core_storage` переносим:**
- Структуры, описывающие:
  - лотерею/розыгрыш (id, владелец, статус, конфиг),
  - билет/участие,
  - историю раундов,
  - базовые ресурсы владельца/хаба.
- Константы ошибок, относящиеся к инвариантам данных (например, невалидный статус, дубликаты и т.п., если они привязаны к хранению).

**В `core_lottery` переносим и упрощаем:**
- Логику:
  - создания раунда/лотереи,
  - покупки билетов,
  - смены статусов (продажа/закрытие/розыгрыш),
  - выбор победителя по результату VRF.
- События:
  - покупка билета,
  - изменение статуса лотереи/раунда,
  - фиксация победителя и суммы выигрыша.

**Удаляем или переписываем заново:**
- Логику, которая смешивает:
  - хранение,
  - бизнес‑правила,
  - входные/выходные интерфейсы для фронтенда,
  - прямые вызовы VRF.
- Всё это должно быть разделено по модулям и пакетам.

### 4.2. `lottery_multi` → `lottery_hub` + `core_lottery`

**В `lottery_hub` переносим:**
- Реестр нескольких лотерей:
  - мэппинг владельцев → список лотерей,
  - функции для перечисления/фильтрации.
- Entry‑функции «верхнего уровня» для фронтенда:
  - создание лотерей по шаблонам,
  - запуск/остановка продаж,
  - запуск розыгрыша (через VRF),
  - чтение сводного статуса.

**В `core_lottery` дорабатываем:**
- Поддержку нескольких типов лотерей (если уже есть в `lottery_multi`).
- Общие механики, которые используются в нескольких сценариях.

### 4.3. `lottery_rewards`

**Сохраняем и переносим:**
- Логику распределения наград,
- механику снапшотов,
- события начислений.

**Приводим к новой архитектуре:**
- Используем структуры хранения из `core_storage`.
- Не храним дублирующую информацию, если её можно получить из ядра.

### 4.4. `lottery_support`

**Извлекаем:**
- Все полезные проверки параметров,
- математические утилиты,
- общие помощники.

**Чистим:**
- Удаляем мёртвый код и функции, которые стали не нужны в новой архитектуре.

### 4.5. `vrf_hub`

**Используем как шаблон:**
- Структуры запросов и результатов VRF,
- события запроса случайности и получения ответа.

**Выделяем явный интерфейс:**
- `request_randomness(...)` — вызывается из `lottery_hub`/`core_lottery`.
- `on_randomness_fulfilled(...)` — вызывается VRF‑системой, внутри которого вызывается логика выбора победителя.

### 4.6. `lottery_factory`

**Оставляем:**
- Низкоуровневые операции создания ресурсов/структур.

**Меняем:**
- Завязываем только на структуры `core_storage`, не на старые типы.

---

## 5. Детальная конфигурация лотерей и правило минимума игроков

### 5.1. Обязательные параметры конфигурации лотереи

Каждая лотерея/розыгрыш должна иметь как минимум:
- `ticket_price: u64` — цена билета в минимальных единицах SUPRA.
- `min_players: u64` — минимальное количество участников для проведения розыгрыша.
- `max_players: u64` — максимальное количество участников (0 — может означать «без жёсткого лимита» или использоваться отдельно).
- `sales_start_ts: u64` — timestamp начала продаж билетов.
- `sales_end_ts: u64` — timestamp окончания продаж билетов.

### 5.2. Расширенные параметры конфигурации

В перспективе (или сразу, если удобно) добавляем:
- `max_tickets_per_wallet: u64` — лимит билетов на один адрес.
- `auto_close_on_max: bool` — нужно ли автоматически закрывать продажи при достижении `max_players`.
- `draw_mode` — режим розыгрыша (например, классический, по этапам, много-победителей).
- `refund_policy` — политика рефандов при недоборе игроков/ошибках:
  - `NoRefund`,
  - `FullRefundIfNotStarted`,
  - `PartialRefund`, и т.п.
- `allow_bots: bool` — разрешены ли тестовые/бот‑аккаунты для этой лотереи.

### 5.3. Инварианты конфигурации

При создании/обновлении конфигурации платформа должна проверять:
- `ticket_price > 0`;
- `min_players > 0`;
- `max_players == 0` **или** `max_players >= min_players`;
- `sales_start_ts < sales_end_ts`;
- окна и лимиты не конфликтуют с глобальной политикой платформы.

При нарушении любого инварианта — `abort E_INVALID_CONFIG` или аналогичным кодом.

### 5.4. Правило минимума игроков (min_players)

**Бизнес‑правило:** розыгрыш **нельзя** проводить до тех пор, пока количество участников не достигнет `min_players`.

- Пока `players_count < min_players`:
  - лотерея может находиться в статусах:
    - `Sales` (идут продажи),
    - `CancelledNotEnoughPlayers` / `OnHoldNotEnoughPlayers` (если `sales_end_ts` прошло, а игроков мало).
- Как только `players_count >= min_players` и:
  - текущее время ≥ `sales_end_ts`,
  - либо достигнут `max_players` (при включённом `auto_close_on_max`),
  - лотерея может переходить в статус `ReadyForDraw`.

Если к моменту окончания окна продаж `players_count < min_players`:
- либо лотерея **отменяется** с рефандом по `refund_policy`,
- либо переводится в статус «ожидание» до ручного решения админа/организатора.

### 5.5. Статусы лотереи и переходы

Примерный набор статусов:
- `Created` — лотерея создана, но продажи ещё не стартовали.
- `Sales` — идёт продажа билетов.
- `SalesClosed` — продажи завершены, идёт подготовка к розыгрышу.
- `ReadyForDraw` — выполнены все условия (включая min_players), можно запускать VRF.
- `DrawRequested` — запрос случайности отправлен в VRF.
- `WinnerSelected` — победитель (или несколько) зафиксирован(ы).
- `CancelledNotEnoughPlayers` — отменено из‑за недостатка игроков.
- `CancelledByAdmin` — отменено админом.

Все переходы между статусами должны быть описаны в `core_lottery`, а `lottery_hub` вызывает соответствующие функции.

### 5.6. События

Для прозрачности и интеграции с фронтендом/анализом:
- `LotteryCreated` — создание лотереи;
- `LotteryConfigUpdated` — изменение конфигурации;
- `TicketPurchased` — покупка билета;
- `LotteryStatusChanged` — изменение статуса;
- `DrawRequested` — запрос VRF для розыгрыша;
- `WinnerSelected` — выбран победитель;
- `LotteryCancelled` — отмена с указанием причины.

---

## 6. Интеграция с Supra VRF

### 6.1. Базовый поток

1. `lottery_hub` или `core_lottery` вызывает функцию `vrf_hub::request_randomness(...)` с:
   - идентификатором лотереи/раунда,
   - параметрами запроса,
   - нужным «payload» (например, hash конфигурации и списка участников).

2. `vrf_hub`:
   - записывает запрос в on-chain структуру (можно использовать старые структуры из текущего `vrf_hub` как шаблон),
   - эмитит событие `RandomnessRequested`.

3. После выполнения VRF‑процесса вызывается callback `vrf_hub::on_randomness_fulfilled(...)`:
   - находит соответствующий запрос по id,
   - передаёт результат (`random_value`) в `core_lottery::apply_vrf_result(...)`.

4. `core_lottery::apply_vrf_result(...)`:
   - выбирает победителя(ей) по результату случайности,
   - обновляет статус лотереи на `WinnerSelected`,
   - эмитит событие `WinnerSelected`/`RewardsAssigned`.

### 6.2. Требования

- Максимально следовать официальным примерам из `Supra-Labs`.
- Все идентификаторы запросов/ответов и события должны быть понятны для последующего аудита.
- В случае ошибок (нет лотереи, повторное использование результата, некорректный статус) — аккуратный `abort` или событие ошибки.

---

## 7. Боты и тестовые аккаунты (player1..player5)

- В проекте уже есть тестовые профили `player1`, `player2`, `player3`, `player4`, `player5`.
- Они используются:
  - в интеграционных тестах,
  - для локальных/тестнет‑розыгрышей,
  - для имитации активности, если реальных игроков мало.

**Правила:**
- Логика участия ботов не должна давать им преимуществ перед реальными игроками (в терминах вероятности выигрыша).
- На mainnet участие таких аккаунтов либо отключается, либо строго прозрачно и явно документируется.
- Настройка параметра `allow_bots` в конфигурации лотереи:
  - если `false` — любые «ботовые» адреса должны фильтроваться на уровне фронта/бэк‑логики;
  - если `true` — боты могут участвовать, но по тем же правилам, что и обычные игроки.

---

## 8. Стратегия тестирования и команды запуска

### 8.1. Базовые команды

Для каждого пакета после изменений необходимо запускать unit‑тесты:

```bash
docker compose -f SupraLottery/compose.yaml run --rm \
  supra_cli bash -lc "\
    cd /supra/SupraLottery && \
    PYTHONPATH=/supra/SupraLottery python3 -m supra.scripts.cli move-test \
      --workspace supra/move_workspace \
      --package <PACKAGE_NAME> \
      --cli /supra/supra \
      --report-json tmp/move-test-<PACKAGE_NAME>.json \
      --report-junit tmp/move-test-<PACKAGE_NAME>.xml \
      --report-log tmp/move-test-<PACKAGE_NAME>.log\
  "
```

Где `<PACKAGE_NAME>` — `lottery_core`, `lottery_hub`, `lottery_rewards` и т.д.

### 8.2. Что считается «зелёным» состоянием

- Компиляция проходит без ошибок.
- Unit‑тесты выполняются без падений.
- Warnings допускаются на первых этапах, но по мере стабилизации их нужно по возможности устранять (особенно связанные с неиспользуемыми переменными или недостижимым кодом).

### 8.3. Расширенное тестирование

- Добавлять unit‑тесты на:
  - проверку инвариантов конфигурации (ticket_price, min/max players, окна продаж),
  - поведение при недостатке игроков,
  - корректность переходов статусов и вызовов VRF,
  - сценарии с рефандами.

---

## 9. Границы с фронтендом

### 9.1. Ожидаемые entry‑функции

Фронтенд должен использовать только ограниченный набор публичных `entry`:
- `lottery_hub::create_lottery_with_config(...)`
- `lottery_hub::buy_ticket(...)`
- `lottery_hub::start_sales(...)` / `stop_sales(...)`
- `lottery_hub::request_draw(...)` (запуск VRF)
- `lottery_hub::claim_reward(...)` (если применимо)

Все остальные функции — внутренние (`public`/`friend` без `entry`).

### 9.2. Данные для отображения во фронтенде

Фронтенду нужны:
- конфигурация лотереи (все поля, описанные в разделе 5);
- текущий статус лотереи;
- количество участников, проданных билетов;
- информация о победителе(ях) и суммах выигрыша;
- история ключевых событий (создание, старт продаж, завершение продаж, розыгрыш, отмена).

Это должно быть доступно через:
- события,
- структурированные ресурсы (через RPC),
- при необходимости — специальные view‑функции.

---

## 10. Этапы реструктуризации

### Этап 1. Подготовка

1. Создать отдельную ветку для рефакторинга (уже сделано).
2. Зафиксировать текущее состояние рабочих пакетов (`lottery_core`, `lottery_multi`, и т.д.) как «источник правды».
3. Настроить быстрый запуск тестов (см. раздел 8).

### Этап 2. Анализ существующих пакетов

1. Пройтись по всем модулям старых пакетов и:
   - выписать ключевые структуры,
   - выписать основные публичные функции,
   - выписать события и их поля,
   - отметить компоненты, которые будут перенесены как есть, и те, что лучше переписать заново.
2. Отдельно проанализировать модуль/модули, связанные с VRF,
   - понять текущий формат запросов/ответов,
   - зафиксировать, какие события используются.

### Этап 3. Создание каркасов новых пакетов

1. Создать минимум:
   - `core_storage` с пустыми или минимальными структурами,
   - `core_lottery` с заглушками логики,
   - `lottery_hub` с entry‑заглушками,
   - при необходимости обновить/создать `lottery_rewards`, `lottery_support`, `vrf_hub` под новую архитектуру.
2. Убедиться, что новые пакеты **компилируются**, даже если функции пока пустые или просто `abort E_NOT_IMPLEMENTED`.

### Этап 4. Миграция хранения (`core_storage`)

1. Перенести все ключевые ресурсы из `lottery_core`/`lottery_multi` в `core_storage`.
2. Обновить зависимости остальных пакетов так, чтобы они использовали новые структуры.
3. Запустить тесты для проверки, что типы согласованы.

### Этап 5. Миграция бизнес‑логики (`core_lottery`)

1. Перенести и адаптировать функции:
   - создание лотерей и раундов,
   - покупка билетов,
   - смена статусов лотереи,
   - выбор победителя по VRF.
2. Реализовать проверку всех инвариантов конфигурации и статусов.
3. Обновить события, чтобы они были консистентны и удобны для фронтенда.

### Этап 6. `lottery_hub` как фасад

1. Реализовать реестр лотерей и владельцев.
2. Реализовать простые entry‑функции для фронтенда, которые внутри вызывают `core_lottery`.
3. Добавить view‑функции или просто ясные ресурсы, чтобы фронтенд мог получать нужную информацию.

### Этап 7. Интеграция с VRF (`vrf_hub`)

1. Привести `vrf_hub` к форме, максимально близкой к официальным примерам Supra.
2. Реализовать поток запросов/ответов, описанный в разделе 6.
3. Связать `vrf_hub` и `core_lottery::apply_vrf_result`.

### Этап 8. Профили, боты, тестовые сценарии

1. Добавить/обновить пакет профилей (`profiles_accounts`):
   - базовые настройки,
   - флаги премиума,
   - настройки отображения адресов.
2. Настроить ботов/тест‑аккаунты (`player1..player5`) через вспомогательные модули или чисто на уровне тестов.
3. Добавить тестовые сценарии, где участвуют как реальные, так и бот‑аккаунты.

### Этап 9. Чистка и подготовка к релизу

1. Удалить старые, неиспользуемые модули и пакеты (или пометить как legacy).
2. Привести все имена, события и ошибки к единому стилю.
3. Минимизировать количество warning‑ов компилятора.
4. Подготовить документацию по entry‑функциям и событиям для фронтенда и аудита.

---

## 11. Что должен знать исполнитель этого плана

1. **Проект SupraLottery ещё не в проде.** Сейчас идёт активная разработка и рефакторинг, поэтому задача — не просто «написать с нуля», а аккуратно использовать уже наработанный, частично рабочий код.
2. **Нельзя ломать Move‑код Unicode‑символами.** В исходниках были ошибки из‑за кириллицы и псевдографики — этого нужно избегать.
3. **Старые пакеты — не мусор, а источник проверенных решений.** Любую новую логику нужно сверять с тем, как она была реализована в `lottery_core`, `lottery_multi`, `lottery_rewards`, `vrf_hub`.
4. **Текущий фокус — ядро на тестнете.** Mainnet — следующий шаг, но архитектуру и безопасность надо закладывать уже сейчас.
5. **Проект позиционируется как честный и прозрачный Web3 dApp.** Это значит максимум событий, понятная логика, отсутствие «магии» и скрытых правил.

Этот план можно использовать как ТЗ для другого чата/разработчика: он содержит контекст, цели, структуру пакетов, детальную конфигурацию лотерей, требования к VRF, ботам, тестам и фронтенду.

