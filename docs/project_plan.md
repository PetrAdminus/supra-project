# План трансформации Supra Lottery

## Основные принципы
- **Эволюция вместо переписывания:** строим VRF-хаб, фабрику лотерей и сопутствующие сервисы поверх текущего репозитория Supra Lottery, сохраняя полезные инструменты и последовательно рефакторя ончейн-состояние.
- **Решения совместно с владельцем продукта:** когда требуется уточнение по функциональности или реализации, команда разработки запрашивает вводные у владельца продукта до начала работ.
- **Масштабируемость по умолчанию:** избегаем уникальных допущений, чтобы каждый компонент (контракты, бэкенд, фронтенд, growth-функции) легко поддерживал новые лотереи, джекпоты, партнёров и регионы без капитальной перестройки.
- **Приоритет Supra-инструментов:** целимся в блокчейн Supra и при любой возможности используем официальные SDK, CLI и инфраструктуру Supra.
- **Двухсетевой режим по умолчанию:** все инструкции, скрипты и конфигурации готовим так, чтобы без изменений работали в тестовой и основной сетях Supra; тестнет служит площадкой разработки, а к релизу контракты, параметры VRF и казначейства должны быть задеплоины и на мейннете.

## Направления работ
### 1. Ончейн-архитектура (VRF-хаб и фабрика лотерей)
- Разделить текущий Move-пакет на отдельные модули для VRF-хаба, фабрики и экземпляров лотерей.
- Ввести `HubState`, который централизует управление подпиской dVRF, whitelisting, лимитами газа и маршрутизацией колбэков.
- Представлять каждую лотерею как запись в `Table<LotteryId, LotteryInstance>` со своими параметрами, книгой билетов и жизненным циклом розыгрыша.
- Реализовать миграционные скрипты: деплой хаба, регистрация наследуемых данных как `LotteryId = 1`, перенос текущего whitelisting и депозитов.
- Базовые пакеты `vrf_hub` и `lottery_factory` уже публикуют состояние с таблицами регистраций, событиями и unit-тестами, подтверждающими логику инициализации, активации и обновления метаданных.
- Модуль `lottery::instances` хранит коллекцию экземпляров, проверяет согласованность VRF-хаба и фабрики, генерирует события создания и синхронизации blueprint и покрыт первыми Move-тестами.
- View-функции `lottery::instances::list_lottery_ids` и `list_active_lottery_ids` позволяют оффчейн-сервисам обнаруживать полный перечень и только активные лотереи без перебора диапазона идентификаторов; тесты подтверждают порядок, целостность списка и корректное переключение статуса.
- Модуль `lottery::rounds` ведёт per-lottery раунды: регистрирует билеты, синхронизируется с казначейством, публикует события расписания и снапшоты состояния; добавлены Move-тесты на покупку билетов, админские сценарии и защиту от операций по деактивированным лотереям.
- VRF-хаб теперь обслуживает очередь запросов случайности, хранит whitelisting callback-отправителя и публикует события `RandomnessRequestedEvent`/`RandomnessFulfilledEvent`.
- Добавлены view-функции `list_lottery_ids`, `list_active_lottery_ids`, `list_pending_request_ids` и `get_request`, что позволяет оффчейн-сервисам без перебора диапазона идентификаторов получать список активных розыгрышей и мониторить висящие заявки VRF.
- `lottery::rounds` интегрирован с VRF-хабом: `request_randomness` ставит заявку в очередь, `fulfill_draw` проверяет whitelisting, извлекает запрос, выбирает победителя и фиксирует `DrawFulfilledEvent`; тесты покрывают полный цикл.
- `lottery::rounds` списывает оплату билета через `treasury_v1::deposit_from_user`, а `treasury_multi` распределяет приз, операционный пул и джекпот с помощью событий `PrizePaidEvent`/`OperationsWithdrawnEvent`/`JackpotPaidEvent`.
- `lottery::jackpot` ведёт список билетов глобального розыгрыша, использует выделенный `lottery_id` VRF-хаба, проверяет регистрацию primary store победителя и перечисляет накопленный джекпот через `treasury_multi::distribute_jackpot_internal`; Move-тесты покрывают успешный цикл и негативный сценарий без средств.
- Модуль `lottery::migration` добавляет функцию `migrate_from_legacy`, переносящую состояние из `main_v2` в таблицы `instances`, `rounds` и `treasury_multi`, задаёт новую конфигурацию долей и очищает ресурс `LotteryData`; Move-тесты проверяют успешную миграцию и отказ при активном pending-запросе VRF.
- `lottery::operators` ведёт реестр владельцев и делегированных операторов для каждой лотереи: `set_owner` фиксирует ответственных, `grant_operator`/`revoke_operator` управляют доступами, события документируют изменения, а view-функции `list_lottery_ids`, `get_owner`, `list_operators`, `can_manage` обеспечивают оффчейн-клиентам и мониторингу прозрачность делегирования. Move-тесты `operators_tests` покрывают позитивные и негативные сценарии.
- `lottery::history` хранит до 128 последних розыгрышей для каждой лотереи: `record_draw` вызывается из `rounds::fulfill_draw`, записывает победителя, сумму приза, случайные байты и payload, публикует `DrawRecordedEvent`, а view-функции `list_lottery_ids`, `get_history`, `latest_record` и `has_history` позволяют API и мониторингу выдавать результаты. Move-тесты `history_tests` подтверждают сохранение записей и очистку администратором.

### 2. Казначейство и экономика
- Расширить `treasury_v1` для управления несколькими призовыми пулами (пер-лотерейные, глобальный джекпот, операционные бюджеты) с настраиваемыми долями в базисных пунктах.
- Отслеживать накопление глобального джекпота из каждой лотереи и связывать выплаты с наградами чек-листа.
- Добавить view-функции и Move-тесты, проверяющие распределения по лотереям и общим пулам.
- Зафиксировать схему распределения и механику джекпота в `docs/adr/treasury-multi-pool.md`.
- Базовый модуль `lottery::treasury_multi` публикует глобальное состояние, конфигурации распределения по лотереям и событие `AllocationRecordedEvent`; view-функции `list_lottery_ids` и `get_lottery_summary` возвращают перечень настроенных розыгрышей с их долями и балансовыми остатками; Move-тесты покрывают успешное распределение, неверные доли и защиту от вызова без конфигурации.
- `treasury_multi` получил помощник `pay_operations_bonus_internal` и событие `OperationsBonusPaidEvent`, позволяющие модулям роста списывать операционный пул для бонусов без участия администратора.
- `lottery::rounds` использует `treasury_multi` для автоматической фиксации поступлений и обновления глобального джекпота при каждой покупке билета, что формирует основу для дальнейших чек-листов и бонусов.
- Модуль `lottery::jackpot` связывает `treasury_multi` с прогрессом чек-листов: выдаёт билеты, инициирует VRF-запросы и распределяет накопленный глобальный пул; события `JackpotTicketGrantedEvent`/`JackpotFulfilledEvent` документируют жизненный цикл розыгрыша и пригодны для панели честности.
- Добавлен модуль `lottery::autopurchase`, позволяющий игрокам пополнять баланс автопокупки, настраивать число билетов на розыгрыш и автоматически выполнять покупки; события и view-функции покрывают не только `get_plan`, но и агрегированные запросы `get_lottery_summary`, `list_players`, `list_lottery_ids`, благодаря чему мониторинг и AutoFi-скрипты видят общий баланс и количество активных планов; Move-тесты проверяют пополнение, исполнение, возврат и корректность сводной статистики.
- Модуль `lottery::vip` реализует платные подписки: `upsert_config` задаёт цену, длительность и число бонусных билетов, `subscribe`/`subscribe_for` списывают оплату и пополняют операционный пул через `record_operations_income_internal`, `bonus_tickets_for` интегрирован в `lottery::rounds`, `cancel`/`cancel_for` завершают подписку, а view-функции (`list_lottery_ids`, `list_players`, `get_subscription`, `get_lottery_summary`) предоставляют агрегированную статистику. Move-тесты `vip_tests` покрывают бонусные билеты и подарочные подписки.

### 3. Аккаунты, прогресс и платформа данных
- Спроектировать постоянную модель профиля пользователя (адрес Supra + никнейм, аватар, соцсети, прогресс чек-листа, история розыгрышей).
- Подготовить миграции PostgreSQL и FastAPI-эндпоинты для профилей, истории участия, достижений и настроек автопокупки билетов.
- Добавить фронтенд-клиенты и состояния, использующие новые API и отображающие управление профилем.
- Обеспечить соблюдение требований по приватности и согласию в рамках экосистемы Supra.
- Реализована стартовая версия `/accounts`: FastAPI-роутер поверх SQLAlchemy (SQLite по умолчанию), поддерживающий создание/обновление и чтение профиля (ник, аватар, соцсети, JSON-настройки); написаны юнит-тесты Python и обновлены e2e-тесты API.
- Фронтенд получил TypeScript-клиент (mock и Supra-режимы) для чтения и обновления профиля через `/accounts`, добавлены юнит-тесты Vitest, проверяющие маппинг полей и формирование payload при upsert.
- Страница фронтенда `/profile` поддерживает чтение и редактирование профиля (никнейм, соцсети, NFT-аватар, JSON-настройки) в mock- и Supra-режимах, синхронизируясь с REST-эндпоинтами `/accounts/*`.
- API фронтенда (`frontend/src/api/supraClient.ts`) теперь преобразует ответ `/status` VRF-хаба в коллекцию `LotterySummary`, синхронизирован с mock-данными и покрыт обновлёнными Vitest-тестами, что готовит UI к каталогу мульти-лотерей.
- На фронтенде появились глобальный стор выбора лотереи и селектор на страницах Dashboard/Tickets: интерфейс показывает каталог доступных розыгрышей, фильтрует историю билетов и использует `PurchaseTicketInput.lotteryId` в mock-режиме.
- Разработан backend-модуль `/progress`: SQLAlchemy-таблицы чек-листов и достижений, REST-роутер FastAPI (`/progress/*`) и сервисные функции для фиксации выполнения; добавлены юнит-тесты Python и интеграционные тесты API.
- Страница фронтенда `/progress` отображает чек-лист и достижения адреса, работает и в mock-, и в Supra-режиме, позволяет отметить задания выполненными и локализована через i18next.
- ⚠️ Фронтендные задачи (редизайн страниц, обновление компонентов) приостановлены до передачи финального макета Figma; текущая работа сконцентрирована на контрактной логике и бэкенде.

### 4. Прозрачность и честность
- Собирать события VRF, хэши payload и снапшоты whitelisting через выделенный сервис-инжестер.
- Открыть аудит-эндпоинты, которые отдают воспроизводимые данные розыгрышей на фронтенд.
- Построить интерфейс «Панель честности», демонстрирующий генерацию seed, доказательство случайности и выбор победителя.
- Хранить артефакты для долгосрочной проверки и регуляторных запросов.
- Python-утилита мониторинга (`supra.scripts.lib.monitoring`) уже собирает состояние VRF-хаба, коллекции мульти-лотерей, многопулового казначейства и теперь включает автопокупку: в отчёте `/status` появляется раздел с суммарными балансами и списком игроков по каждой лотерее.
- Тот же отчёт расширен секцией `metadata`: мониторинг вызывает `lottery::metadata::list_lottery_ids` и `get_metadata`, поэтому фронтенд и Supra AutoFi получают витринные описания розыгрышей из одного источника без дублирования с CMS.
- Тот же отчёт расширен секцией `operators`: мониторинг читает `lottery::operators::list_lottery_ids`, `get_owner` и `list_operators`, что позволяет Supra AutoFi, админ-панели и фронтенду видеть ответственных и делегированных операторов по каждой лотерее.
- Тот же отчёт расширен блоком `referrals`: для каждой лотереи возвращаются конфигурация бонусов и агрегированные выплаты, что упрощает настройку growth-кампаний и контроль операционного пула.
- Добавлен раздел `vip`: мониторинг подтягивает `lottery::vip::get_lottery_summary` и `list_players`, чтобы фронтенд и Supra AutoFi видели выручку подписок, активных участников и список адресов без дополнительных запросов.
- Модуль `supra.scripts.lib.vrf_audit` и команда CLI `vrf-audit` выгружают события `DrawRequestIssued/DrawFulfilled` и `RandomnessRequested/RandomnessFulfilled`, а REST-эндпоинт `/lotteries/{id}/vrf-log` отдаёт агрегированный отчёт для будущей панели честности.
- Фронтенд получил страницу `/fairness`, которая отображает VRF-журнал, снепшоты раундов и события хаба для выбранной лотереи с настройкой лимита событий.
- Интерфейс панели честности поддерживает фильтрацию по типу события и поисковому запросу, что облегчает анализ запросов VRF и сопоставление ответов.

### 5. Real-time коммуникации и уведомления
- Внедрить слой WebSocket/SSE для лобби-чата, объявлений о лотереях и трансляции результатов.
- Хранить историю чата с политиками модерации и сроками хранения, задокументированными в `docs/policies/chat-moderation.md`.
- Отображать уведомления на фронтенде и интегрировать механики шаринга результатов в соцсети.
- Реализован базовый сервис `/chat`: REST-эндпоинты для сообщений и объявлений, SQLAlchemy-таблицы, WebSocket `/chat/ws/{room}` и
  тесты `test_chat_rest_roundtrip`/`test_websocket_receives_broadcast`, подтверждающие сохранение и push-рассылку.
- На дашборде добавлена панель чата и объявлений: фронтенд загружает данные через `/chat/messages`/`/chat/announcements`, в Supra-режиме автоматически подключается WebSocket, а в mock-режиме работает локальное хранилище.

### 6. NFT-стратегия и награды
- Определить, какие NFT выпускаем сами, а какие берём у партнёров (например, Crystara), и зафиксировать подход в `docs/adr/nft-strategy.md`.
- При необходимости реализовать Move-модули для выпуска трофеев победителей и связать их с результатами лотерей.
- Синхронизировать метаданные на бэкенде и отрисовывать выбор аватаров/трофеев в профилях пользователей.
- Модуль `lottery::nft_rewards` уже выпускает уникальные бейджи победителей: события `BadgeMintedEvent`/`BadgeBurnedEvent`, view-функции `has_badge`/`list_badges`/`get_badge` и Move-тесты подтверждают корректность минта, ограничение по администратору и возможность ручного сжигания владельцем.

### 7. Поддержка, контент и локализация
- Обновить инфраструктуру i18n, чтобы поддерживать несколько локалей и динамический контент.
- Создать центр поддержки с FAQ, формой тикетов и редакционными гайдами.
- Предоставить инструменты для извлечения переводов и выкладки контента (`frontend/scripts/extract-translations.ts`).
- Реализован базовый центр поддержки: SQLAlchemy-таблицы статей и тикетов, REST-эндпоинты `/support/*`, тесты сервиса и API.
- Внедрены `i18next` и `react-i18next`, добавлен ADR `docs/adr/i18n-cms.md`, хук `useI18n` построен на стандартном API, а скрипт `pnpm run i18n:extract` выгружает словари в `frontend/public/locales/*`.

### 8. Интеграция дизайн-системы
- Перенести предстоящий Figma-дизайн в переиспользуемые токены (цвет, типографика, отступы) и применить их ко всей библиотеке React-компонентов.
- Пересобрать базовые layout-компоненты, страницы каталога и детальные карточки лотерей по спецификации Figma.
- Обновить истории Storybook и визуальные регрессионные тесты, чтобы зафиксировать новый гайд.
- Подготовить `docs/design-system.md` с правилами использования для будущих компонентов.

### 9. Безопасность, комплаенс и операции
- Определить ожидания KYC/AML и регуляторные ограничения для мульти-лотерей (`docs/adr/compliance.md`).
- Запланировать внешние аудиты Move-контрактов и бэкенда и оформить план в `docs/security/audit_plan.md`.
- Настроить runbook’и реагирования на инциденты, процедуры отзывов ключей и проверки в CI (статический анализ, сканирование зависимостей).
- Усилить мониторинг VRF-хаба, балансов казначейства и real-time сервисов (дашборды, алерты).
- Подготовить двусетевой пайплайн деплоя: поддерживать отдельные профили Supra CLI (`testnet` и `mainnet`), синхронизированные версии пакетов и runbook’и переключения окружений, включая whitelisting и управление ключами.

### 10. Аналитика и рост
- Собирать продуктовые метрики (DAU, покупки билетов, выполнение чек-листов, эффективность рефералок) и описать их в `docs/adr/analytics.md`.
- Поток событий с бэкенда и фронтенда направить в аналитическое хранилище (ClickHouse/BigQuery) с дашбордами (Metabase/Superset).
- Реализовать growth-механики: билеты за чек-лист, реферальные и тестерские награды, магазин монетизации (NFT или VIP-подписки). Автопокупка билетов реализована на ончейн-уровне (`lottery::autopurchase`) и готова к интеграции с оффчейн-сервисами и UX.
- `lottery::referrals` уже реализует реферальную программу: конфигурацию бонусов на лотерею, регистрацию связей игрок → реферер, автоматические выплаты из операционного пула и view-статистику для мониторинга; покрыт Move-тестами `referrals_tests`.
- `lottery::store` добавляет магазин цифровых товаров: администратор управляет ассортиментом через `upsert_item` и `set_availability`, игроки покупают товары напрямую из кошелька через `purchase`, а выручка отражается в операционном пуле (`treasury_multi::record_operations_income_internal`). View-функции `list_lottery_ids`, `list_item_ids` и `get_lottery_summary` обеспечивают мониторинг каталога; Move-тесты `store_tests` покрывают списание запасов и защиту от перепродажи.
- `lottery::metadata` разворачивает реестр витринных описаний (название, описание, ссылки, изображение) для каждой лотереи, публикует события `LotteryMetadataUpsertedEvent`/`LotteryMetadataRemovedEvent` и предоставляет view-функции `list_lottery_ids`, `has_metadata`, `get_metadata`; Move-тесты `metadata_tests` проверяют обновление записей и защиту от неавторизованных вызовов.
- Подготовить бренд-активы (название, логотип, промо-сайт) и синхронизировать маркетинг с запуском лотерей.

## Дорожная карта поставки
1. **Этап 0 – Исследование и архитектура:** подтвердить требования, создать ADR, согласовать дизайн-токены и подготовить общий инструментарий.
2. **Этап 1 – Ончейн-ядро:** реализовать VRF-хаб, фабрику лотерей, расширения казначейства и миграционные скрипты с Move-тестами.
   - Статус: VRF-хаб, фабрика, коллекция экземпляров, модуль раундов и многопуловое казначейство развернуты и связаны между собой; добавлены события регистрации, синхронизации blueprint, управления раундами и Move-тесты на основные сценарии.
3. **Этап 2 – Бэкенд-платформа:** развернуть сервис аккаунтов, сбор данных, real-time слой, fairness-API и автоматизации Supra AutoFi.
4. **Этап 3 – Фронтенд-опыт:** интегрировать Figma-дизайн, построить каталог/детали лотерей, управление профилем, чат, панель честности и локализацию.
5. **Этап 4 – Growth-функции:** запустить чек-листы, розыгрыши глобального джекпота, автопокупку, реферальные и тестерские бонусы, NFT-награды и магазин.
6. **Этап 5 – Запуск и сопровождение:** провести аудиты, нагрузочные тесты, комплаенс-проверки, маркетинговый релиз и наладить пост-релизную аналитику.
   - Дополнительно: зафиксировать успешный деплой и smoke-тесты VRF-хаба, фабрики и мульти-лотерей в обеих сетях (`testnet`/`mainnet`), синхронизировать адреса и параметры в документации и runbook’ах.

## Открытые вопросы и участие владельца продукта
- Вопросы по продукту, экономике или дизайну, требующие решения, будем выносить владельцу продукта до начала разработки.
- Новые инструменты Supra или партнёрские интеграции оцениваем совместно, чтобы сохранить совместимость с возможностями экосистемы.

## Как стартовать
- Использовать текущий репозиторий как фундамент, постепенно заменяя модули и сервисы согласно дорожной карте.
- Раннее развернуть общую инфраструктуру (БД, очереди сообщений, аналитический конвейер), чтобы команды могли работать параллельно.
- По возможности применять Supra CLI, Supra AutoFi и другие официальные инструменты, оставаясь нацелёнными на блокчейн Supra.

