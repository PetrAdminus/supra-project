# Типовые ошибки Supra Move CLI

Ниже перечислены повторяющиеся проблемы, которые мы сталкивали при сборке и прогоне Move-тестов через Supra CLI. Каждому пункту сопоставлен текст ошибки и краткая рекомендация по устранению.

## 1. `error[E01002]: unexpected token` из-за `let mut`
* **Симптом**: компилятор сообщает `Unexpected 'mut'` и указывает на строку вида `let mut counter = 0;`.
* **Причина**: Supra CLI использует синтаксис Move, где переменные по умолчанию изменяемые. Ключевое слово `mut` не поддерживается и приводит к синтаксической ошибке.
* **Решение**: удалите `mut` и используйте простое `let counter = 0;`. Переприсваивание (`counter = counter + 1;`) остаётся допустимым.

## 2. `error[E03002]: unbound module` для `0x1::u64`/`0x1::u128`
* **Симптом**: сообщение `Invalid 'use'. Unbound module: '0x1::u64'` или аналогичное для `u128`.
* **Причина**: в Supra Move стандартные числовые утилиты не экспортируются как отдельные модули `0x1::u64`/`0x1::u128`.
* **Решение**: работайте с базовыми функциями языка (`from_u8`, `max_value`) через собственные хелперы. В проекте для этого используются `safe_add_u64`, `safe_mul_u128`, `u8_to_u64` и пр. (`lottery::main_v2`).

## 3. `error[E04001]`/`error[E04013]` при обращении к константам из тестов
* **Симптом**: тесты падают с сообщением `Constants are internal to their module` или `invalid statement or expression in constant` при попытке присвоить `const SOME = main_v2::E_*`.
* **Причина**: константы в Move видимы только внутри своего модуля.
* **Решение**: вместо прямого обращения вызывайте публичные view/тестовые функции, возвращающие нужные значения или ожидайте abort-коды через события/результаты.

## 4. `error[E04004]`/`error[E04005]` при использовании `option::Option` с кортежами
* **Симптом**: ошибки вида `Expected a single non-reference type, but found: '(u128, u128, u128)'`.
* **Причина**: в Supra Move нельзя хранить кортежи внутри `Option` или возвращать их из `public` функций.
* **Решение**: определите отдельную структуру-обёртку (например, `ClientWhitelistSnapshotView`) и возвращайте её через `Option`.

## 5. `error[E05001]: ability constraint not satisfied` при использовании `&*resource`
* **Симптом**: сообщение `Invalid dereference. Dereference requires the 'copy' ability` при попытке вызвать `&*lottery` или передать ресурсный тип в функцию, ожидающую значение.
* **Причина**: оператор `*` создаёт копию ресурса, но тип `LotteryData` не имеет способности `copy`.
* **Решение**: передавайте ссылки напрямую (`&lottery`, `&mut lottery`) и обновите сигнатуры вспомогательных функций так, чтобы они принимали ссылки, а не значения.

## 6. `error[E03003]: unbound module member bcs::from_bytes`
* **Симптом**: `Invalid module access. Unbound function 'from_bytes' in module '(std=0x1)::bcs'`.
* **Причина**: Supra CLI поставляет модуль `0x1::bcs`, а не `std::bcs`.
* **Решение**: импортируйте и используйте `0x1::bcs` напрямую.

## 7. `error[E04007]: incompatible types` при возврате `Option`
* **Симптом**: компилятор сообщает `Invalid return expression` и ожидает `option::Option<T>`, но на выходе оказывается `();`.
* **Причина**: ветки `if`/`else` не возвращают значение, а завершаются `return` без аргумента либо пропускают `option::some`/`option::none`.
* **Решение**: убеждайтесь, что каждая ветка возвращает `option::some(...)` или `option::none(...)`, либо заранее проверяйте отсутствие состояния и досрочно `return option::none();`. Пример из официального гайда Supra: функции `get_*` возвращают `option::Option` c явным `some/none` ([Supra Docs — Working with Option](https://docs.supra.com/docs/supra-move/working-with-option)).

## 8. Безопасное извлечение значения из `Option`
* **Симптом**: попытка использовать `option::extract(&mut opt)` приводит к ошибкам типов, если нет изменяемой ссылки.
* **Решение**: следуйте рекомендациям Supra и распаковывайте значение через `option::destroy_some(opt)`, который принимает `Option` по значению и повторяет паттерны официальных примеров ([Supra Docs — Working with Option](https://docs.supra.com/docs/supra-move/working-with-option)). Это избавляет от необходимости хранить промежуточную `&mut` ссылку и делает код совместимым с Supra Move.

Эти правила уже отражены в текущей кодовой базе (`lottery::main_v2`) и тестах. Перед началом новой задачи сверяйтесь с данным списком, чтобы избегать повторных ошибок.
